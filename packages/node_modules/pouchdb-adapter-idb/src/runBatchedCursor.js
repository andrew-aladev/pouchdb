// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations
// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or
// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because
// we're not processing each document one-at-a-time.
function runBatchedCursor(objectStore, keyRange, descending, batchSize,
                          preferSequential, onBatch) {

  // Bail out of getAll()/getAllKeys() in the following cases:
  // 1) either method is unsupported - we need both
  // 2) batchSize is 1 – might as well use IDBCursor; it's one fewer request
  // 3) descending – no real way to do this via getAll()/getAllKeys()
  // 4) In preferSequential mode, we assume the user is doing some filtering
  //    (e.g. changes()) and thus is sensitive to not reading in the entire
  //    database, so we prefer using a cursor if batchSize === -1 (i.e. unbounded).
  //    But if we're not in preferSequential mode, then we assume the user just
  //    wants all documents anyway (e.g. allDocs()), so if batchSize === -1 we
  //    will still use getAll()/getAllKeys().

  // TODO: add option to skip getAllKeys when keys can be derived from values
  // (e.g. for allDocs())

  var useGetAll = typeof objectStore.getAll === 'function' &&
    typeof objectStore.getAllKeys === 'function' &&
    batchSize !== 1 && !descending &&
    (!preferSequential || batchSize > 1);

  var keysBatch;
  var valuesBatch;
  var pseudoCursor;

  function onGetAll(e) {
    valuesBatch = e.target.result;
    if (keysBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function onGetAllKeys(e) {
    keysBatch = e.target.result;
    if (valuesBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function continuePseudoCursor() {
    if (!keysBatch.length) { // no more results
      return onBatch();
    }
    // fetch next batch, exclusive start
    var lastKey = keysBatch[keysBatch.length - 1];
    var newKeyRange;
    if (keyRange && keyRange.upper) {
      try {
        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,
          true, keyRange.upperOpen);
      } catch (e) {
        if (e.name === "DataError" && e.code === 0) {
          return onBatch(); // we're done, startkey and endkey are equal
        }
      }
    } else {
      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);
    }
    keyRange = newKeyRange;
    keysBatch = null;
    valuesBatch = null;
    getAll(/* keys */false, objectStore, keyRange, batchSize).onsuccess = onGetAll;
    getAll(/* keys */true, objectStore, keyRange, batchSize).onsuccess = onGetAllKeys;
  }

  function onCursor(e) {
    var cursor = e.target.result;
    if (!cursor) { // done
      return onBatch();
    }
    // regular IDBCursor acts like a batch where batch size is always 1
    onBatch([cursor.key], [cursor.value], cursor);
  }

  if (useGetAll) {
    pseudoCursor = {"continue": continuePseudoCursor};
    getAll(/* keys */false, objectStore, keyRange, batchSize).onsuccess = onGetAll;
    getAll(/* keys */true, objectStore, keyRange, batchSize).onsuccess = onGetAllKeys;
  } else if (descending) {
    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;
  } else {
    objectStore.openCursor(keyRange).onsuccess = onCursor;
  }
}

function getAll(keys, objectStore, keyRange, batchSize) {
  if (batchSize === -1) {
    // -1 means unlimited, but firefox throws an error if you pass -1 in
    if (keys) {
      return objectStore.getAllKeys(keyRange);
    } else {
      return objectStore.getAll(keyRange);
    }
  } else {
    if (keys) {
      return objectStore.getAllKeys(keyRange, batchSize);
    } else {
      return objectStore.getAll(keyRange, batchSize);
    }
  }
}

export default runBatchedCursor;